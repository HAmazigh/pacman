#include "Game.h"

#define PAC	1
#define GHOST1 2
#define GHOST2 3
#define GHOST3 4
#define GHOST4 5

extern Log logtxt;
extern App app;
extern Settings settings;

void Game::editorSave() {
	int i=-1, j=-1;

	if ( settings.baddiestartx == -1 ||
		settings.baddiestarty == -1 ||
		settings.pacstartx == -1 ||
		settings.pacstarty == -1 ) {
			std::cerr << "Specify pacman and ghost start locations before saving\n";
			return;
	}

//	if ( saveas || editorpath.length() == 0 ) {
//		//getfilename
//		OPENFILENAME ofn;
//		CHAR buf[256] = ".\\levels\\map.txt";
//
//		ZeroMemory( &ofn, sizeof(ofn) );
//		ofn.lStructSize = sizeof(OPENFILENAME);
//		ofn.hwndOwner = app.getWindowHandle();
//		ofn.hInstance = NULL;
//		ofn.lpstrFilter = "Map Files\0map.txt\0\0";
//		ofn.lpstrCustomFilter = NULL;
//		ofn.nMaxCustFilter = NULL;
//		ofn.nFilterIndex = 1;
//		ofn.lpstrFile = buf;
//		ofn.nMaxFile = 256;
//		ofn.lpstrFileTitle = NULL;
//		ofn.nMaxFileTitle = NULL;
//		ofn.lpstrInitialDir = NULL;
//		ofn.lpstrTitle = NULL;
//		ofn.Flags = OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;
//		ofn.nFileOffset = 11;
//		ofn.nFileExtension = 14;
//		ofn.lpstrDefExt = "txt";
//
//
//
//		GetSaveFileName( &ofn );
//
//		editorpath = buf;
//		i = (int)editorpath.find("levels\\");
//		j = (int)editorpath.find("map.txt");
//
//		if ( i == -1 || j == -1) {
//			editorpath = "";
//			MessageBox( app.getWindowHandle(), "Maps must be named \"map.txt\" and stored in the \"\\levels\" directory", "Error saving map", MB_OK);
//			return;
//		}
//		else {
//			editorpath.erase(0, i);
//			i = (int)editorpath.find("map.txt");
//			editorpath.erase(i);
//		}
//
//	}

	//save


	std::ofstream file;
	bool error=0;		//1 on error


    if (editorpath == "") editorpath = "./levels/new/";
	file.open( (editorpath + MAPFILE).c_str()/*, std::ios::out */);

	if (!file) error=true;

	if (!error) {
		file << "/ Pacman Revolutions mapfile generated by Pacman level editor"	<< std::endl;
		for (j=0;j<settings.fieldheight; j++) {
			for (i=0;i<settings.fieldwidth; i++) {
				file << map[j*settings.fieldwidth+i] << "  ";
			}
			file << std::endl;
		}
	}

	if (file.is_open() ) file.close();


	file.open( (editorpath + OBJFILE).c_str() );
	if (!file) error=1;

	if (!error) {
		file << "/ Pacman Revolutions objectmap generated by Pacman level editor"	<< std::endl;
		for (j=0;j<settings.fieldheight; j++) {
			for (i=0;i<settings.fieldwidth; i++) {
				file << objmap[j*settings.fieldwidth+i] << "  ";
			}
			file << std::endl;
		}
	}

	if (file.is_open() ) file.close();

	file.open ( ( editorpath + CFGFILE ).c_str());
	if (!file) error=true;

	if (!error) {
		file << "/ Pacman Revolutions config file generated by Pacman level editor =;"	<< std::endl;
		file << "FIELDWIDTH=" << settings.fieldwidth << ";" << std::endl;
		file << "FIELDHEIGHT=" << settings.fieldheight << ";" << std::endl;
		file << "TILESIZE=" << settings.tilesize << ";" << std::endl;
		file << "PACSPEED=" << settings.pacspeed << ";" << std::endl;
		file << "BADDIESPEED=" << settings.baddiespeed << ";" << std::endl;
		file << "BADDIEIQ=" << settings.baddieiq << ";" << std::endl;
		file << "VULN_DURATION=" << settings.vuln_duration << ";" << std::endl;
		file << "PACSTARTX=" << settings.pacstartx  << ";" << std::endl;
		file << "PACSTARTY=" << settings.pacstarty << ";" << std::endl;
		file << "BADDIESTARTX=" << settings.baddiestartx << ";" << std::endl;
		file << "BADDIESTARTY=" << settings.baddiestarty << ";" << std::endl;
	}
	if ( file.is_open() ) file.close();

	bool isincluded = false;
	for (i=0;i< settings.lvlpathcount;i++) {
		if ( editorpath == settings.lvlpath[i] ) isincluded = true;
	}
	if ( !isincluded && !error) {
		file.open("pacman.cfg", std::ios::out | std::ios::app);
		if (!file) error=true;
		else {
			file << "\nLEVEL_PATH=" << editorpath;
			if (file.is_open()) file.close();
			settings.lvlpath.push_back(editorpath);
			settings.lvlpathcount++;
		}
	}


	if (error) {
		std::cerr << "Save failed";
	}
}

void Game::logicEditor() {

	if ( inputwaiting) {
		if ( key == LEFT ) {

			if ( activetool == 0 ) activetool = 15;
			else activetool--;
		}
		else if ( key == RIGHT ) {

			if ( activetool == 15 ) activetool = 0;
			else activetool++;
		}
		else if ( key == CLICK ) {
			if (activetool < 10)
				map[settings.fieldwidth*(mouseY / settings.tilesize)+(mouseX / settings.tilesize)] = activetool;
			else if (activetool == 14) {
				settings.pacstartx = mouseX / settings.tilesize;
				settings.pacstarty = mouseY / settings.tilesize;
			}
			else if (activetool == 15 ) {
				settings.baddiestartx = mouseX / settings.tilesize;
				settings.baddiestarty = mouseY / settings.tilesize;
			}
			else
				objmap[settings.fieldwidth*((mouseY - 10) / settings.tilesize)+((mouseX-10) / settings.tilesize)] = activetool-10;
		}
	}

}

void Game::renderEditor() {
	int i;

	objects[0]->Draw();

	for (i=1;i<10;i++) {
		if ( i == activetool )
			((BckgrObj*)objects[0])->Draw( 10 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 0, 255);
		else
			((BckgrObj*)objects[0])->Draw( 10 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 0, 100);
	}
	for (i=1;i<4;i++) {
		if ( i == activetool - 10 )
			((BckgrObj*)objects[0])->Draw( 310 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 1, 255);
		else
			((BckgrObj*)objects[0])->Draw( 310 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 1, 100);
	}
	if ( activetool == 14 ) {
		objects[PAC]->setAlpha(255);
		objects[PAC]->Draw(430, settings.fieldheight * settings.tilesize + 5 );
	}
	else {
		objects[PAC]->setAlpha(100);
		objects[PAC]->Draw(430, settings.fieldheight * settings.tilesize + 5 );
	}
	if ( activetool == 15 ) {
		objects[GHOST1]->setAlpha(255);
		objects[GHOST1]->Draw(480, settings.fieldheight * settings.tilesize + 5 );
	}
	else {
		objects[GHOST1]->setAlpha(100);
		objects[GHOST1]->Draw(480, settings.fieldheight * settings.tilesize + 5 );
	}

	objects[PAC]->Draw(settings.pacstartx*settings.tilesize, settings.pacstarty * settings.tilesize );
	objects[GHOST1]->Draw(settings.baddiestartx * settings.tilesize, settings.baddiestarty * settings.tilesize);

}

void Game::initEditor() {
	int i, j;

//    std::cout << "debug: " + editorpath;
//	editorpath = "";
	if ( map ) delete[] map;
	if ( objmap ) delete[] objmap;

	//create new empty maps
	if ( editorpath == "" ) {
		map = new int[ settings.fieldheight * settings.fieldwidth ];
		objmap = new int[ settings.fieldheight * settings.fieldwidth ];

		for (i=0;i<settings.fieldheight * settings.fieldwidth;i++) {
			map[i]=0;
			objmap[i]=0;
		}
		settings.baddiestartx = -1;
		settings.baddiestarty = -1;
		settings.pacstartx = -1;
		settings.pacstarty = -1;
		settings.gatex = -1;
		settings.gatey = -1;
	}
	//load existing map
	else {
		//getfilename
//		OPENFILENAME ofn;
//		bool ok = true;
//		CHAR buf[256] = ".\\levels\\map.txt";
//
//		ZeroMemory( &ofn, sizeof(ofn) );
//		ofn.lStructSize = sizeof(OPENFILENAME);
//		ofn.hwndOwner = app.getWindowHandle();
//		ofn.hInstance = NULL;
//		ofn.lpstrFilter = "Map Files\0map.txt\0\0";
//		ofn.lpstrCustomFilter = NULL;
//		ofn.nMaxCustFilter = NULL;
//		ofn.nFilterIndex = 1;
//		ofn.lpstrFile = buf;
//		ofn.nMaxFile = 256;
//		ofn.lpstrFileTitle = NULL;
//		ofn.nMaxFileTitle = NULL;
//		ofn.lpstrInitialDir = NULL;
//		ofn.lpstrTitle = NULL;
//		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
//		ofn.nFileOffset = 11;
//		ofn.nFileExtension = 14;
//		ofn.lpstrDefExt = "txt";
//
//
//
//		GetOpenFileName( &ofn );
//
//		editorpath = buf;
//		i = (int)editorpath.find("levels\\");
//		j = (int)editorpath.find("map.txt");
//
//		if ( i == -1 || j == -1) {
//			editorpath = "";
//			MessageBox( app.getWindowHandle(), "Maps must be named \"map.txt\" and stored in the \"\\levels\" directory", "Error opening map", MB_OK);
//			return;
//		}
//		else {
//			editorpath.erase(0, i);
//			i = (int)editorpath.find("map.txt");
//			editorpath.erase(i);
//		}

		//load settings

		settings.LoadSettings( editorpath + CFGFILE );

		//if level has different field size than currently selected, setup new window with proper size
        if (settings.fieldwidth*settings.tilesize != app.getScreen()->w
            || settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != app.getScreen()->h) {
            app.InitWindow();
            logtxt.print("window resized...");
        }

		//load maps

		map = new int[ settings.fieldheight * settings.fieldwidth ];
		objmap = new int[ settings.fieldheight * settings.fieldwidth ];

		loadMap( editorpath + MAPFILE, map);
		loadMap( editorpath + OBJFILE, objmap);

		//if loading is successful, set editorpath

//		if ( !ok ) {
//			MessageBox( app.getWindowHandle(), "Loading failed", "Loading failed", MB_OK);
//			editorpath = "";
//		}
	}

}
void Game::changeSkin() {
	int i;
	for (i=0;i<NUMOFOBJECTS;i++) objects[i]->LoadTextures( settings.skinspath[settings.skinspathcurrent] );
}
void Game::emptyMsgPump() {

	SDL_Event ev;

	while ( SDL_PollEvent(&ev) == 1 ) {
        switch(ev.type) {
            case SDL_KEYDOWN:
                switch (ev.key.keysym.sym ) {
                    case SDLK_ESCAPE:
                    case SDLK_q:
                        app.setQuit(true);
                        break;
                    case SDLK_UP:
                        processInput(UP);
                        ((Pacman*)objects[1])->setNextDir( UP );
                        break;
                    case SDLK_DOWN:
                        processInput(DOWN);
                        ((Pacman*)objects[1])->setNextDir( DOWN );
                        break;
                    case SDLK_LEFT:
                        processInput(LEFT);
                        ((Pacman*)objects[1])->setNextDir( LEFT );
                        break;
                    case SDLK_RIGHT:
                        processInput(RIGHT);
                        ((Pacman*)objects[1])->setNextDir( RIGHT );
                        break;
                    case SDLK_SPACE:
                        boost();
                        break;
                    case SDLK_p:
                        if ( getState() == STATE_GAME )
                            pause();
                        break;
                    case SDLK_n:
                        if ( getState() != STATE_ENTER_HSCORE )
                            gameInit();
                        break;
                    case SDLK_l:
                        settings.lvlpathcurrent++;
                        if ( settings.lvlpathcurrent >= settings.lvlpathcount)
                            settings.lvlpathcurrent=0;
                        gameInit();
                        break;
                    case SDLK_s:
                        settings.skinspathcurrent++;
                        if ( settings.skinspathcurrent >= settings.skinspathcount)
                            settings.skinspathcurrent=0;
                        changeSkin();
                        break;
                    case SDLK_e:
                        initEditor();
                        setState( STATE_EDITOR );
                        break;
                    case SDLK_w:
//                        std::cerr << "w: save map not yet implemented";
                        editorSave();
                        break;
                    case SDLK_f:
                        toggleFps();
                        break;
                    case SDLK_h:
       					setState( STATE_VIEW_HSCORE );
                        break;
                    case SDLK_RETURN:
                        processInput(ENTER);
                        break;
                    default:
                        break;
                }
                break;
            case SDL_MOUSEBUTTONDOWN:
                if ( getState() == STATE_EDITOR )
                    processInput( CLICK, ev.button.x , ev.button.y);
                break;
//            case SDL_MOUSEBUTTONUP:
//                std::cout << "debug: mouse button up event \n";
//                break;
            case SDL_MOUSEMOTION:
                if ( getState() == STATE_EDITOR && ev.motion.state&SDL_BUTTON(1) )
                    processInput( CLICK, ev.motion.x, ev.motion.y);
                break;
//            case SDL_KEYUP:
//                std::cout << "debug: key up event \n";
//                break;
            default:
//                std::cout << "debug: other event\n";
                break;
        }
    }
}
void Game::toggleSound() {

	if ( sounds->on) {
		sounds->toggleSounds();
	}
	else {
		sounds->toggleSounds();

		if (gamestarted && !ispaused ) sounds->play(10, 1);
		if (gamestarted && vulnflag && !ispaused ) sounds->play(7, 1);
	}
}
void Game::clearHscore() {
	hscore.clear();
}

void Game::renderViewHscore() {
	SDL_Surface *buf = app.getScreen(),
        *txt;
    SDL_Color col={255,255,255};
	std::ostringstream ostr, scstr;
	SDL_Rect rect;
	int i, sc;
	std::string nm;

	rect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
	rect.w = 400;
	rect.y = settings.fieldheight*settings.tilesize / 2 - 200;
	rect.h = 50;

	try {
		// DRAW FIELD + SPRITES

		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

		// DRAW SCORE + INFO

		for (i=1; i<lives; i++) {
			objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize);
		}
		if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +10 );

		ostr << "level: " << level << " score: " << score;
//		if ( font->DrawText( sprite, ostr.str().c_str(), -1, &scorebox, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//			throw Error("DrawText level: score: failed");
        txt=TTF_RenderText_Solid(font,ostr.str().c_str(),col);
		if (!txt)
            throw Error("DrawText failed");
        SDL_BlitSurface(txt,NULL,buf,&scorebox);
        SDL_FreeSurface(txt);

		// DRAW HIGHSCORES

//		if ( font->DrawText( sprite, "HIGHSCORES", -1, &rect, DT_CENTER, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//			throw Error("DrawText HIGHSCORES failed");
        txt=TTF_RenderText_Solid(font,"HIGHSCORES:",col);
		if (!txt)
            throw Error("DrawText failed");
        SDL_BlitSurface(txt,NULL,buf,&rect);
        SDL_FreeSurface(txt);

		for (i=0;i<MAXENTRIES;i++) {

			nm= "";
			nm=hscore.getName(i);
			sc=hscore.getScore(i);

			rect.x = settings.fieldwidth * settings.tilesize / 4;
			rect.w = 200;
			rect.y = 200 + i*50;
			rect.h = 50;

			if ( nm != "" ) {
//				if ( font->DrawText( sprite, nm.c_str() , -1, &rect, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//					throw Error("DrawText nm.c_str() failed");
                txt=TTF_RenderText_Solid(font,nm.c_str(),col);
                if (!txt)
                    throw Error("DrawText failed");
                SDL_BlitSurface(txt,NULL,buf,&rect);
                SDL_FreeSurface(txt);
			}

			rect.x = settings.fieldwidth * settings.tilesize / 4 + 200;


			scstr.str("");
			if ( sc ) {
				scstr << sc;
//				if ( font->DrawText( sprite, scstr.str().c_str() , -1, &rect, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//					throw Error("DrawText scstr.str().c_str() failed");
                txt=TTF_RenderText_Solid(font,scstr.str().c_str(),col);
                if (!txt)
                    throw Error("DrawText failed");
                SDL_BlitSurface(txt,NULL,buf,&rect);
                SDL_FreeSurface(txt);
			}
		}

	}


	catch ( Error& err ) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in RenderViewHscore";
		app.setQuit(true);
		logtxt.print( "Unexpected error" );
	}
}

void Game::setState(int st) {
	int i;

	if ( st == STATE_GAME ) {


		sounds->stop();
		sounds->play(10,1);

		for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( false);

//		ModifyMenu( app.getMenuHandle(), ID_GAME_PAUSE, MF_BYCOMMAND | MF_ENABLED, ID_GAME_PAUSE, "Pause");
//		ModifyMenu( app.getMenuHandle(), ID_CONFIGURATION_CHANGELEVEL, MF_BYCOMMAND | MF_ENABLED, ID_CONFIGURATION_CHANGELEVEL, "Change level...");
	}
	else if ( st == STATE_ENTER_HSCORE ) {

		sounds->stop();

		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
		for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(150);

//		ModifyMenu( app.getMenuHandle(), ID_GAME_PAUSE, MF_BYCOMMAND | MF_GRAYED, ID_GAME_PAUSE, "Pause");
//		ModifyMenu( app.getMenuHandle(), ID_CONFIGURATION_CHANGESKIN, MF_BYCOMMAND | MF_GRAYED, ID_CONFIGURATION_CHANGESKIN, "Change skin...");
//		ModifyMenu( app.getMenuHandle(), ID_CONFIGURATION_CHANGELEVEL, MF_BYCOMMAND | MF_GRAYED, ID_CONFIGURATION_CHANGELEVEL, "Change level...");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_HIGHSCORES, MF_BYCOMMAND | MF_GRAYED, ID_GAME_HIGHSCORES, "View Highscores");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_CLEARHIGHSCORES, MF_BYCOMMAND | MF_GRAYED, ID_GAME_CLEARHIGHSCORES, "Clear Highscores");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_NEWGAME, MF_BYCOMMAND | MF_GRAYED, ID_GAME_NEWGAME, "New Game");

	}
	else if ( st == STATE_VIEW_HSCORE ) {


		sounds->stop();
		sounds->play( 11, 0);

		for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(150);
		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);

//		ModifyMenu( app.getMenuHandle(), ID_GAME_PAUSE, MF_BYCOMMAND | MF_GRAYED, ID_GAME_PAUSE, "Pause");
//		ModifyMenu( app.getMenuHandle(), ID_CONFIGURATION_CHANGESKIN, MF_BYCOMMAND | MF_ENABLED, ID_CONFIGURATION_CHANGESKIN, "Change skin...");
//		ModifyMenu( app.getMenuHandle(), ID_CONFIGURATION_CHANGELEVEL, MF_BYCOMMAND | MF_ENABLED, ID_CONFIGURATION_CHANGELEVEL, "Change level...");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_HIGHSCORES, MF_BYCOMMAND | MF_ENABLED, ID_GAME_HIGHSCORES, "View Highscores");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_CLEARHIGHSCORES, MF_BYCOMMAND | MF_ENABLED, ID_GAME_CLEARHIGHSCORES, "Clear Highscores");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_NEWGAME, MF_BYCOMMAND | MF_ENABLED, ID_GAME_NEWGAME, "New Game");
	}
	else if ( st == STATE_STOPPED && state != STATE_STOPPED) {
		sounds->stop();
		sounds->play(0, 1);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
		for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
	}
	else if ( st == STATE_EDITOR ) {

		sounds->stop();

		for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);

		activetool = 1;

//		ModifyMenu( app.getMenuHandle(), ID_EDITOR_SAVE, MF_BYCOMMAND | MF_ENABLED, ID_EDITOR_SAVE, "Save");
//		ModifyMenu( app.getMenuHandle(), ID_EDITOR_SAVEAS, MF_BYCOMMAND | MF_ENABLED, ID_EDITOR_SAVEAS, "Save As...");
//		ModifyMenu( app.getMenuHandle(), ID_GAME_PAUSE, MF_BYCOMMAND | MF_GRAYED, ID_GAME_PAUSE, "Pause");
//		ModifyMenu( app.getMenuHandle(), ID_CONFIGURATION_CHANGELEVEL, MF_BYCOMMAND | MF_GRAYED, ID_CONFIGURATION_CHANGELEVEL, "Change level...");
	}

	if ( st != STATE_EDITOR ) {
//		ModifyMenu( app.getMenuHandle(), ID_EDITOR_SAVE, MF_BYCOMMAND | MF_GRAYED, ID_EDITOR_SAVE, "Save");
//		ModifyMenu( app.getMenuHandle(), ID_EDITOR_SAVEAS, MF_BYCOMMAND | MF_GRAYED, ID_EDITOR_SAVEAS, "Save As...");
	}

	state = st;

}

void Game::logicEnterHscore() {
	int j;

	if ( inputwaiting ) {

		switch ( key ) {
			case RIGHT :
				if (hscoreselection==2) hscoreselection=0;
				else hscoreselection++;
				for (j=0;j<3;j++) namecol[j]= 150;
				namecol[ hscoreselection ] = 255;
				break;
			case LEFT :
				if (hscoreselection==0) hscoreselection=2;
				else hscoreselection--;
				for (j=0;j<3;j++) namecol[j]= 150;
				namecol[ hscoreselection ] = 255;
				break;
			case DOWN :
				if (name[hscoreselection]=='A') name[hscoreselection]='_';
				else if (name[hscoreselection]=='_') name[hscoreselection]='Z';
				else name[hscoreselection]--;
				break;
			case UP :
				if (name[hscoreselection]=='Z') name[hscoreselection]='_';
				else if (name[hscoreselection]=='_') name[hscoreselection]='A';
				else name[hscoreselection]++;
				break;
			case ENTER :
				hscore.add(name, score);
				hscore.save();

				setState( STATE_VIEW_HSCORE) ;
			default :
				break;
		}
	}
}
void Game::logicGame() {
	int		i, j,
			delta,
			pacX,
			pacY,
			pacXpix,
			pacYpix,
			ghostXpix[4],
			ghostYpix[4],
			oldscore(score);

	delta = (int)(time -oldtime);

	if ( gamestarted && !ispaused ) {

		//////////////////////////////////
		//	GET POSITIONS
		//////////////////////////////////

		pacXpix = ((Pacman*)objects[PAC])->getXpix();
		pacYpix = ((Pacman*)objects[PAC])->getYpix();
		pacX= (pacXpix + settings.tilesize / 2) / settings.tilesize;
		pacY= (pacYpix + settings.tilesize / 2) / settings.tilesize;
		for (i=0;i<4;i++) {
			ghostXpix[i]= ((Ghost*)objects[i+2])->getXpix();
			ghostYpix[i]= ((Ghost*)objects[i+2])->getYpix();
		}

		//////////////////////////////////
		// MOVE LOGIC
		//////////////////////////////////

		if ( delta < 100 )  {
			//set ghost targets - 2 on pacman, 2 on next intersection

			{
				int tmpx(  pacXpix / settings.tilesize),
					tmpy(  pacYpix / settings.tilesize);

				((Ghost*)objects[GHOST1])->setTarget( tmpx, tmpy);
				((Ghost*)objects[GHOST2])->setTarget( tmpx, tmpy);

				((Pacman*)objects[PAC])->nextIntersection ( tmpx, tmpy);

				((Ghost*)objects[GHOST3])->setTarget( tmpx, tmpy);
				((Ghost*)objects[GHOST4])->setTarget( tmpx, tmpy);
			}

			//move objects

			for (i=0;i<NUMOFOBJECTS;i++)
				objects[i]->Update( delta );
		}
		///////////////////////////////////////////
		//	TIME LOGIC
		///////////////////////////////////////////

		//if ghost timer is up, set ghosts to normal mode

		if ( vulnflag && time > ghosttick ) {
			for (i=0;i<4;i++) {
				if ( ((Ghost*)objects[i+2])->getState() != 3) ((Ghost*)objects[i+2])->setState(0);
			}
			vulnflag= false;
			deadghostcount= 0;

			sounds->stop(7);
		}

		// if less than 2 secs left in vuln mode, set warning mode

		else if ( vulnflag && time > ghosttick -2000) for (i=0;i<4;i++) {
			((Ghost*)objects[i+2])->setState(2);
//			sounds->modify( 7, 44100 + (2000 - (ghosttick-time))*10 );
		}

		// fruit stuff

		if ( specialspawned && !specialeaten && (fruittick - time < 2000) ) {
			((BckgrObj*)objects[0])->setFruitAlpha( 55 + (fruittick - time) / 10 );
		}
		if ( time > fruittick && specialspawned && !specialeaten) {
			specialspawned = false;
			((BckgrObj*)objects[0])->setSpecialSpawned(false);
		}

		// pac booster

		if ( isboosted && time > boosttick ) {
			isboosted = false;
			((Pacman*)objects[PAC])->setSpeedMult( 1 );
		}

		///////////////////////////////////////////
		// PACMAN LOCATION LOGIC
		///////////////////////////////////////////

		for (i=0; i< 4; i++) {
			//if (pacX == baddieX[i] && pacY == baddieY[i] ) {
			if (	pacXpix > ghostXpix[i] - 10  &&
					pacXpix < ghostXpix[i] + 10  &&
					pacYpix > ghostYpix[i] - 10  &&
					pacYpix < ghostYpix[i] + 10  ) {

				if ( ((Ghost*)objects[i+2])->getState() == 0 )	{

					lives--;

					sounds->stop();
					sounds->play(8, 0);

                    SDL_Delay(1000);

					if ( lives == 0) {
						if (hscore.onlist(score) ) setState( STATE_ENTER_HSCORE );
						else gameInit();
						return;
					}
					else {
						resetLvl();
						return;
					}
				}

				else if  ( ((Ghost*)objects[i+2])->getState() != 3 ) {
					((Ghost*)objects[i+2])->setState(3);

					sounds->play(4,0);
					deadghostcount++;

					floatingscore = 200;
					for (j=1; j< deadghostcount; j++) floatingscore *= 2;
					floatingscorebox.x = pacXpix;
					floatingscorebox.w = 100;
					floatingscorebox.y = pacYpix-70;
					floatingscorebox.h = 50;

					floatingscorecounter = 100;

					score+= floatingscore;
				}
			}
		}

		if ( objmap[pacY * settings.fieldwidth + pacX ] == 1 ) {
			objmap[pacY * settings.fieldwidth + pacX ] = 0;
			score += SMALL_DOTS_SCORE;

			sounds->play( 1 + soundcounter%2, 0, 44100, -500);
			soundcounter++;
		}
		else if ( objmap[pacY * settings.fieldwidth + pacX ] == 2 ) {
			objmap[pacY * settings.fieldwidth + pacX ] = 0;
			score += LARGE_DOTS_SCORE;

			sounds->play(3, 0);
			sounds->play(7, 1, 44100);

			//set ghosts to vulnerable mode

			for (i=2;i<6;i++) ((Ghost*)objects[i])->setState(1);
			deadghostcount=0;	//reset dead counter

			//start ghost timer

			ghosttick = time + settings.vuln_duration;
			vulnflag = true;
		}
		else if ( objmap[pacY * settings.fieldwidth + pacX ] == 3 &&  specialspawned && !specialeaten ) {
			objmap[pacY * settings.fieldwidth + pacX ] = 0;
			score += objscore;

			sounds->play(5, 0);

			floatingscorebox.x = pacXpix;
			floatingscorebox.w = 100;
			floatingscorebox.y = pacYpix-70;
			floatingscorebox.h = 50;
			floatingscore = objscore;
			floatingscorecounter = 100;

			specialeaten = true;
			((BckgrObj*)objects[0])->setSpecialEaten(true);
		}


		///////////////////////////////////
		//	OTHER
		///////////////////////////////////

		if ( (score >= 10000 && oldscore < 10000) ||
				(score >=100000 && oldscore < 100000) ||
				(score >=1000000 && oldscore < 1000000) ) {
			lives++;

			sounds->play(6, 0);
		}

		if ( !specialhasbeenspawned && ((BckgrObj*)objects[0])->getObjCount() == specialspawntime) {
			specialspawned = true;
			((BckgrObj*)objects[0])->setFruitAlpha(255);
			((BckgrObj*)objects[0])->setSpecialSpawned(true);
			fruittick = SDL_GetTicks() + FRUITDURATION;
		}

		if ( ((BckgrObj*)objects[0])->getObjCount() == 0 ) {
			levelcleared = true;
			render();
			nextLvl();
		}
//		else ( sounds->modify( 10, 44100 - ((BckgrObj*)objects[0])->getObjCount() * 75) );
	}

}
void Game::renderEnterHscore() {
	SDL_Surface* buf = app.getScreen(),
        *txt;
	std::ostringstream ostr;
	SDL_Rect rect;
	SDL_Color col={255,255,255};
	int i;
	std::string tmp;

	rect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
	rect.w = 400;
	rect.y = settings.fieldheight*settings.tilesize / 2 - 50;
	rect.h = 50;

	try {
		// DRAW FIELD + SPRITES

		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

		// DRAW SCORE + INFO

		for (i=1; i<lives; i++) {
			objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize+5);
		}
		if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );

		ostr << "level: " << level << " score: " << score;
//		if ( font->DrawText( sprite, ostr.str().c_str(), -1, &scorebox, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//			throw Error("DrawText failed");
        txt=TTF_RenderText_Solid(font,ostr.str().c_str(),col);
		if (!txt)
            throw Error("DrawText failed");
        SDL_BlitSurface(txt,NULL,buf,&scorebox);
        SDL_FreeSurface(txt);

		// DRAW HIGHSCORE ENTRY

//		if ( font->DrawText( sprite, "NEW HIGHSCORE!", -1, &rect, DT_CENTER, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//			throw Error("DrawText failed");
        txt=TTF_RenderText_Solid(font,"NEW HIGHSCORE!",col);
		if (!txt)
            throw Error("DrawText failed");
        SDL_BlitSurface(txt,NULL,buf,&rect);
        SDL_FreeSurface(txt);

		rect.y += 50;

//		if ( font->DrawText( sprite, "Enter name:", -1, &rect, DT_CENTER, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//			throw Error("DrawText failed");
        txt=TTF_RenderText_Solid(font,"Enter name:",col);
		if (!txt)
            throw Error("DrawText failed");
        SDL_BlitSurface(txt,NULL,buf,&rect);
        SDL_FreeSurface(txt);

		rect.y += 70;
		rect.h = 50;
		rect.x = settings.fieldwidth*settings.tilesize / 2 - 60;
		rect.w = 40;

		for (i=0;i<3;i++) {
		    tmp=name[i];
            col.r=col.g=col.b=namecol[i];
    //		if ( font->DrawText( sprite, tmp.c_str(), -1, &rect, DT_CENTER, D3DCOLOR_XRGB(namecol[0], namecol[0], namecol[0]) ) == 0 )
    //			throw Error("DrawText failed");
            txt=TTF_RenderText_Solid(font,tmp.c_str(),col);
            if (!txt)
                throw Error("DrawText failed");
            SDL_BlitSurface(txt,NULL,buf,&rect);
            SDL_FreeSurface(txt);
		    rect.x=rect.x+40;
		}


	}
	catch ( Error& err ) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in Game::RenderEnterHscore";
		app.setQuit(true);
		logtxt.print( "Unexpected error" );
	}
}
void Game::renderNormal() {
	int i;
	std::ostringstream ostr;
	SDL_Color col={255,255,255};
	SDL_Surface *txt;

	try {
		// DRAW FIELD + SPRITES

		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

		// DRAW SCORE + INFO

		for (i=1; i<lives; i++) {
			objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize+5);
		}
		if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );
		if ( boostavailable ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 60 -10, settings.fieldheight*settings.tilesize +15, 4 );

		ostr << "level: " << level << " score: " << score;
//		if ( font->DrawText( sprite, ostr.str().c_str(), -1, &scorebox, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
		txt=TTF_RenderText_Solid(font,ostr.str().c_str(),col);
		if (!txt)
            throw Error("DrawText failed");
        SDL_BlitSurface(txt,NULL,app.getScreen(),&scorebox);
        SDL_FreeSurface(txt);

		//DRAW SCORE POPUP
		if (floatingscorecounter != 0) {
			std::ostringstream scoretext;

			scoretext << floatingscore;
			floatingscorecounter--;

			floatingscorebox.y--;

//			if ( font->DrawText( sprite, scoretext.str().c_str(), -1, &floatingscorebox, DT_LEFT, D3DCOLOR_ARGB(55+floatingscorecounter*2, 255, 255, 255) ) == 0 )
            txt=TTF_RenderText_Solid(font,scoretext.str().c_str(),col);
            if (!txt)
				throw Error("DrawText failed");
			SDL_SetAlpha(txt,SDL_SRCALPHA,	55+floatingscorecounter*2);
			SDL_BlitSurface(txt,NULL,app.getScreen(),&floatingscorebox);
            SDL_FreeSurface(txt);
		}

		// PAUSE

		if ( ispaused ) {
			SDL_Rect pauserect;
			pauserect.y = settings.fieldwidth*settings.tilesize / 2 - 100;
			pauserect.w = 200;
			pauserect.x = settings.fieldheight*settings.tilesize / 2 - 10;
			pauserect.h = 50;

//			if ( font->DrawText( sprite, "PAUSED", -1, & pauserect, DT_CENTER, D3DCOLOR_XRGB( 255, 255, 255) ) == 0 )
            txt=TTF_RenderText_Solid(font,"PAUSED",col);
            if (!txt)
				throw Error("DrawText failed");
			SDL_BlitSurface(txt,NULL,app.getScreen(),&pauserect);
            SDL_FreeSurface(txt);
		}

		// LEVEL CLEARED

		else if ( levelcleared ) {
			SDL_Rect pauserect;
			pauserect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
			pauserect.w = 400;
			pauserect.y = settings.fieldheight*settings.tilesize / 2 - 10;
			pauserect.h = 50;
//
//			if ( font->DrawText( sprite, "LEVEL CLEARED!", -1, & pauserect, DT_CENTER, D3DCOLOR_XRGB( 255, 255, 255) ) == 0 )
            txt=TTF_RenderText_Solid(font,"LEVEL CLEARED!",col);
            if (!txt)
				throw Error("DrawText failed");
			SDL_BlitSurface(txt,NULL,app.getScreen(),&pauserect);
            SDL_FreeSurface(txt);
		}
	}

	catch ( Error& err ) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in Game::RenderNormal";
		app.setQuit(true);
		logtxt.print( "Unexpected error during RenderNormal()" );
	}
}

void Game::boost() {
	if ( boostavailable ) {

		sounds->play( 12, 0 );

		boosttick = SDL_GetTicks() + BOOSTTIME;
		isboosted = true;
		boostavailable = false;
		((Pacman*)objects[PAC])->setSpeedMult( 2 );
	}
}
bool Game::pause() {
	int i;



	if ( !ispaused ) {
		ispaused = true;
		sounds->stop();
		for (i=0;i<NUMOFOBJECTS;i++) objects[i]->setPaused( true);

		pausetick = SDL_GetTicks();

//		CheckMenuItem( app.getMenuHandle(), ID_GAME_PAUSE, MF_CHECKED);

		return ispaused;
	}
	else {
		ispaused = false;
		sounds->play(10, 1);
		if (vulnflag) sounds->play(7, 1);
		for (i=0;i<NUMOFOBJECTS;i++) objects[i]->setPaused( false);

		int delta( SDL_GetTicks() - pausetick );

//		CheckMenuItem( app.getMenuHandle(), ID_GAME_PAUSE, MF_UNCHECKED);

		ghosttick += delta;
		fruittick += delta;
		boosttick += delta;

		return ispaused;
	}
}
void Game::nextLvl() {
	std::string tmpstr;


	try {
		level++;

		sounds->stop();
		sounds->play(9);

		objscore*=2;
		settings.vuln_duration -= settings.vuln_duration/10;

		((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%15, rand()%5 );
		((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%10, rand()%3 );

		objects[PAC]->reset(settings.pacstartx, settings.pacstarty);
		objects[GHOST1]->reset(settings.baddiestartx, settings.baddiestarty);
		objects[GHOST2]->reset(settings.baddiestartx+2, settings.baddiestarty);
		objects[GHOST3]->reset(settings.baddiestartx-2, settings.baddiestarty);
		objects[GHOST4]->reset(settings.baddiestartx, settings.baddiestarty-2);

		tmpstr = settings.lvlpath[settings.lvlpathcurrent] + OBJFILE;
		if ( ! loadMap(tmpstr, objmap) )
			throw Error("Error loading objmap.txt during Game::nextLvl()");

		vulnflag= false;
		deadghostcount= 0;
		floatingscorecounter = 0;
		floatingscore = 0;
		specialspawned = false;
		((BckgrObj*)objects[0])->setSpecialSpawned(false);
		specialeaten = false;
		((BckgrObj*)objects[0])->setSpecialEaten(false);
		specialhasbeenspawned = false;
		time = oldtime = SDL_GetTicks();
		ghosttick = 0;
		isboosted = false;
		((Pacman*)objects[PAC])->setSpeedMult( 1);
		boostavailable = true;
		levelcleared = false;

		if (ispaused) pause();


		SDL_Delay(1000);


		render();
		specialspawntime = rand() % (((BckgrObj*)objects[0])->getObjCount() -20) + 10;

		emptyMsgPump();
		inputwaiting = false;
		gamestarted = false;
	}
	catch ( Error &err) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in Game::nextLvl()";
		app.setQuit(true);
		logtxt.print( "Unexpected error" );
	}
}

void Game::gameInit(std::string level, std::string skin, bool editor) {
	int i;
	std::string tmpstr;

	try {
		isinit=false;
		sounds->stop();

        //try to set level/skins path
        settings.setPath(MODE_LEVELS,level);
        settings.setPath(MODE_SKINS,skin);

		tmpstr = settings.lvlpath[settings.lvlpathcurrent] + CFGFILE;

		if ( !settings.LoadSettings(tmpstr) )
			throw Error("Error loading level settings");

		//resetting variables
		score=0;
		vulnflag= false;
		deadghostcount= 0;
		ghosttick = 0;
		floatingscorecounter = 0;
		floatingscore = 0;
		lives = 3;
		level = 1;
		objscore = 200;
		specialspawned = false;
		specialeaten = false;
		specialhasbeenspawned = false;
		inputwaiting = false;
		gamestarted = false;
		isboosted = false;
		time = oldtime = SDL_GetTicks();
		boostavailable = true;
		levelcleared = false;
		setState( STATE_GAME);
		name = "AAA";
		namecol[0] = 255;
		namecol[1] = 150;
		namecol[2] = 150;
		hscoreselection = 0;


		if ( ispaused ) {
			pause();
		}
//		else CheckMenuItem( app.getMenuHandle(), ID_GAME_PAUSE, MF_UNCHECKED);

		scorebox.x= 20;
		scorebox.w = 500;
		scorebox.y = settings.fieldheight * settings.tilesize ;
		scorebox.h = 50;



	//DYNAMIC OBJECTS INIT
		if (map!=NULL) {
			delete[] map;
			map=NULL;
		}
		if (objmap!=NULL) {
			delete[] objmap;
			objmap=NULL;
		}
		for (i=0; i< NUMOFOBJECTS; i++) {
			if (objects[i]!=NULL) {
				delete objects[i];
				objects[i] = NULL;
			}
		}

		logtxt.print("Unloading complete");

        //if level has different field size than currently selected, setup new window with proper size
        if (settings.fieldwidth*settings.tilesize != app.getScreen()->w
            || settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != app.getScreen()->h) {
            app.InitWindow();
            logtxt.print("window resized...");
        }

		// INIT MAPS
		map = new int[settings.fieldheight*settings.fieldwidth];
		objmap = new int[settings.fieldheight*settings.fieldwidth];

		tmpstr = settings.lvlpath[settings.lvlpathcurrent];

		if ( !loadMap(tmpstr + MAPFILE, map) )
			throw Error("Failed to load map.txt");
		if ( !loadMap(tmpstr + OBJFILE, objmap) )
			throw Error("Failed to load objmap.txt");

		logtxt.print("Maps loaded");

		//creating font

		if ( !font ) loadFont();

		logtxt.print("Font created");
//
//		//creating sprite
//
//		if ( D3DXCreateSprite( app.getD3DDevice() , &sprite ) != S_OK )
//			throw Error("Failed to create sprite");
//
//		logtxt.print("Sprite created");

		//loading level graphics

		objects[0] = new BckgrObj( app.getScreen(), 10 );
		objects[0]->LoadTextures(settings.skinspath[settings.skinspathcurrent]);

		logtxt.print("Level background loaded");

		//loading sounds

//		if ( ! sounds->init()) return;

		logtxt.print("Sounds loaded");

		sounds->play(9, 0);

		setState( STATE_STOPPED);

		hscore.setfilename(settings.lvlpath[settings.lvlpathcurrent] + "hscore");
		hscore.load();


		//create pacman + ghosts

		objects[1] = new Pacman( app.getScreen(),
							20,
							settings.pacstartx,
							settings.pacstarty,
							settings.pacspeed,
							settings.tilesize,
							settings.fieldheight,
							settings.fieldwidth,
							map);
		objects[1]->LoadTextures(settings.skinspath[settings.skinspathcurrent]);

		objects[2] = new Ghost( app.getScreen(),
							20,
							settings.baddiestartx,
							settings.baddiestarty,
							settings.baddiespeed + rand()%20 + 10,
							settings.tilesize,
							settings.fieldheight,
							settings.fieldwidth,
							map,
							"1");
		objects[2]->LoadTextures(settings.skinspath[settings.skinspathcurrent]);

		objects[3] = new Ghost( app.getScreen(),
							20,
							settings.baddiestartx+2,
							settings.baddiestarty,
							settings.baddiespeed + rand()%20-10,
							settings.tilesize,
							settings.fieldheight,
							settings.fieldwidth,
							map,
							"2");
		objects[3]->LoadTextures(settings.skinspath[settings.skinspathcurrent]);

		objects[4] = new Ghost( app.getScreen(),
							20,
							settings.baddiestartx-2,
							settings.baddiestarty,
							settings.baddiespeed + rand()%20-10,
							settings.tilesize,
							settings.fieldheight,
							settings.fieldwidth,
							map,
							"3");
		objects[4]->LoadTextures(settings.skinspath[settings.skinspathcurrent]);

		objects[5] = new Ghost( app.getScreen(),
							20,
							settings.baddiestartx,
							settings.baddiestarty-2,
							settings.baddiespeed + rand()%20 - 10,
							settings.tilesize,
							settings.fieldheight,
							settings.fieldwidth,
							map,
							"4");
		objects[5]->LoadTextures(settings.skinspath[settings.skinspathcurrent]);

		for (i=0;i<4;i++) ((Ghost*)objects[i+2])->changeDifficulty(0, settings.baddieiq);	//SET DIFFICULTY SPECIFIED IN CONFIG FILE

		logtxt.print("Objects loaded");

		//calculate special fruit spawn time

		if (!editor) render();
		specialspawntime = rand() % (((BckgrObj*)objects[0])->getObjCount() -20) + 10;

		emptyMsgPump();
		inputwaiting = false;
		gamestarted = false;

		isinit = true;

        if (editor) {
            initEditor();
            setState(STATE_EDITOR);
        }
	}
	catch ( Error &err) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in Game::gameInit()";
		app.setQuit(true);
		logtxt.print( "Unexpected error" );
	}
}


void Game::resetLvl() {	// vars and positions when pacman dies during level

	sounds->stop();

	SDL_Delay(1000);

	sounds->play(9);


	// setting vars
	vulnflag= false;
	deadghostcount= 0;
	floatingscorecounter= 0;
	floatingscore= 0;
	ghosttick = 0;
	isboosted = false;
	((Pacman*)objects[PAC])->setSpeedMult( 1);

	if (ispaused) pause();

	objects[PAC]->reset(settings.pacstartx, settings.pacstarty);
	objects[GHOST1]->reset(settings.baddiestartx, settings.baddiestarty);
	objects[GHOST2]->reset(settings.baddiestartx+2, settings.baddiestarty);
	objects[GHOST3]->reset(settings.baddiestartx-2, settings.baddiestarty);
	objects[GHOST4]->reset(settings.baddiestartx, settings.baddiestarty-2);

	render();

	emptyMsgPump();
	gamestarted= false;
	inputwaiting = false;

}
void Game::processInput(int k, int ix, int iy) {

	inputwaiting = true;

	key = k;
	if ( k == CLICK ) {
		mouseX = ix;
		mouseY = iy;
	}

	if ( !gamestarted && !ispaused ) {
		gamestarted = true;
		if ( state == STATE_STOPPED || state == STATE_GAME )
			setState( STATE_GAME );
	}
}

void Game::processLogic() {

	time = SDL_GetTicks();

	if ( state == STATE_GAME ) logicGame();
	else if (state == STATE_ENTER_HSCORE ) logicEnterHscore();
	else if (state == STATE_EDITOR ) logicEditor();

	oldtime = time;
	inputwaiting = false;
}

void Game::getMaps( int **m, int **o) {
	(*m)=map;
	(*o)=objmap;
}
bool Game::loadMap(std::string file, int* memmap) {
	int i, count=0, size = settings.fieldheight * settings.fieldwidth;
	std::string tmp;
	char c('i');
	std::ifstream mp;

	mp.open( file.c_str() );

	if (!mp ) {
		logtxt.print(file + " - Loading error");
		app.setQuit(true);
		return false;
	}

	for (i=0;i<size;i++) {
		do {
			if ( mp.eof() ) break;
			c=mp.get();
			if (c == '/' ) {	// enable comments in map file by prefixing line with  a slash
				getline(mp, tmp);
				continue;
			}
		}
		while (! (c >= '0' && c <= '9') ) ;
		memmap[i]=c-48;
		count++;
		if (!mp) break;
	}

	if ( mp.is_open() ) mp.close();

	if (count != size) {
		logtxt.print(file + " - Loading error");
		app.setQuit(true);
		return false;
	}
//	bool chk = true;
//	if ( file.find("objmap.txt") == -1 ) {
//		for (j=0;j<settings.fieldheight && chk;j++) {
//			for (i=0;i<settings.fieldwidth && chk;i++) {
//				if ( memmap[ j*settings.fieldwidth + i] == 2) {
//					settings.gatex = i;
//					settings.gatey = j;
//					chk = false;
//
//				}
//			}
//		}
//	}


	logtxt.print(file + " loaded");
	return true;
}


std::string Game::getFPS() {
	unsigned int newtick = SDL_GetTicks();
	std::ostringstream ostr;
	float diff;

	diff = (float)(newtick-ticks) / (float)counter;	// ms per frame

	diff = 1000.0f / diff;			// frames per s

	ostr << diff << "fps";

	ticks = newtick;

	return ostr.str();
}

void Game::render() {
	SDL_Surface *buf = app.getScreen(),
            *txt;
	SDL_Color col={255,255,255};


	if (counter == 100) {
		fps = getFPS();
		counter = 0;
	}

	try {
		if ( !renderisbusy ) {
			renderisbusy = true;

//			d3ddev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(0,0,0), 1.0f, 0);

//			if ( d3ddev->BeginScene() != D3D_OK )
//				throw Error("BeginScene failed");

//			sprite->Begin(D3DXSPRITE_ALPHABLEND);


			////////////////////////////////
			// STATE SWITCH
			////////////////////////////////

			if ( (state == STATE_GAME) || (state == STATE_STOPPED) ) renderNormal();
			else if (state == STATE_ENTER_HSCORE ) renderEnterHscore();
			else if (state == STATE_VIEW_HSCORE ) renderViewHscore();
			else if (state == STATE_EDITOR )renderEditor();




			if ( showfps ) {
//				if ( font->DrawText( sprite, fps.c_str(), -1, &fpsbox, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255) ) == 0 )
//					throw Error("DrawText failed");
                txt=TTF_RenderText_Solid(font,fps.c_str(),col);
                if (!txt)
                    throw Error("DrawText failed");
                SDL_BlitSurface(txt,NULL,buf,&fpsbox);
                SDL_FreeSurface(txt);
			}

//			sprite->End();

//			if ( d3ddev->EndScene() != D3D_OK )
//				throw Error("EndScene failed");

            SDL_Flip(buf);

//			if ( d3ddev->Present( NULL, NULL, NULL, NULL) != D3D_OK )
//				throw Error("Present failed");

			renderisbusy = false;
			counter++;
		}
	}
	catch ( Error& err ) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in Game::Render";
		app.setQuit(true);
		logtxt.print( "Unexpected error during Render()" );
	}
}

bool Game::loadFont() {

	try {
//		if ( D3DXCreateFont(	app.getD3DDevice(),
//								48,
//								NULL,
//								FW_NORMAL,
//								1,
//								false,
//								ANSI_CHARSET,
//								OUT_DEFAULT_PRECIS,
//								DEFAULT_QUALITY,
//								DEFAULT_PITCH | FF_DONTCARE,
//								"Kidprint",
//								&font) != S_OK )
        font=TTF_OpenFont("arial.ttf",24);
        if (!font)
			throw Error("Failed to create font object ");
	}

	catch ( Error& err ) {
		std::cerr << err.getDesc();
		app.setQuit(true);
		logtxt.print( err.getDesc() );
		return false;
	}
	catch ( ... ) {
		std::cerr << "Unexpected exception in Game::loadFont";
		app.setQuit(true);
		logtxt.print( "Unexpected error while loading font" );
		return false;
	}

	logtxt.print("Font loaded");
	return true;
}

Game::Game()
:	state(STATE_STOPPED),
	font(NULL),
//	sprite(NULL),
	counter(0),
	map(NULL),
	objmap(NULL),
	deadghostcount(0),
	inputwaiting(false),
	vulnflag(false),
	gamestarted(false),
	lives(2),
	specialspawned(false),
    specialeaten(false),
	specialhasbeenspawned(false),
	ispaused(false),
	isboosted(false),
	objscore(200),
	floatingscore(0),
	floatingscorecounter(0),
	specialspawntime(0),
	level(1),
	hscoreselection(0),
	showfps(false),
	renderisbusy(false),
	isinit(false),
	soundcounter(0)

{
	int i;

//	timeBeginPeriod(1);
	time = oldtime = ticks = SDL_GetTicks();

	fps = "loading";

	fpsbox.x= 10;
	fpsbox.w = 290;
	fpsbox.y = 10;
	fpsbox.h = 190;

	for (i=0;i<NUMOFOBJECTS;i++) objects[i]=NULL;

    for (i=0;i<10;i++)
        num[i]='0'+i;

	name = "AAA";
	namecol[0] = 255;
	namecol[1] = 150;
	namecol[2] = 150;

	sounds = new Sounds();
}

Game::~Game()
{
	int i;

//	timeEndPeriod(1);

	if ( font ) TTF_CloseFont(font);
//	if ( sprite ) sprite->Release();
    if ( sounds ) delete sounds;

	for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) delete objects[i];

	if ( map ) delete[] map;
	if ( objmap ) delete[] objmap;
}
